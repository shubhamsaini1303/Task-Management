exports.register = async (req, res) => {
  try {
    const { name, email, password } = req.body;

    // Validate input fields
    if (!name || !email || !password) {
      return res.status(400).json({ 
        message: "All fields are required.", 
        status: 0 
      });
    }

    // Check if the user already exists
    const existingUser = await UserModel.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ 
        message: "Email already registered.", 
        status: 0 
      });
    }

    // Hash the password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Create new user
    const newUser = new UserModel({
      name,
      email,
      password: hashedPassword,
    });

    // Save the user to the database
    await newUser.save();

    res.status(201).json({
      message: "User registered successfully.",
      newUser,
      status: 1,
    });
  } catch (error) {
    console.error("Error during user registration:", error);
    res.status(500).json({ 
      message: "Something went wrong.", 
      status: 0, 
      error: error.message 
    });
  }
}; write json code for test in postmen for create user



const Task = require("../models/taskmodel");

// Create Task
exports.createTask = async (req, res) => {
  try {
    const { title, description, dueDate } = req.body;
    const userId = req.user.id; // User ID from authentication middleware

    const task = new Task({
      title,
      description,
      dueDate,
      user: userId,
    });

    await task.save();
    res.status(201).json({ message: "Task created successfully", task });
  } catch (error) {
    res.status(500).json({ message: "Error creating task", error: error.message });
  }
};

// Get User's Tasks
exports.mytasks = async (req, res) => {
  try {
    const userId = req.user.id;

    const tasks = await Task.find({ user: userId });
    res.status(200).json({ tasks });
  } catch (error) {
    res.status(500).json({ message: "Error fetching tasks", error: error.message });
  }
};

// Update Task by User
exports.updatebyuser = async (req, res) => {
  try {
    // Extract userId from req.user (assumes authentication middleware is adding user info to req.user)
    const userId = req.user.id;

    // Extract taskId from params and updates from the request body
    const { id: taskId } = req.params; // taskId is passed as a parameter
    const updates = req.body;

    // Validate taskId and updates
    if (!taskId) {
      return res.status(400).json({ message: "Task ID is required" });
    }

    if (!updates || Object.keys(updates).length === 0) {
      return res.status(400).json({ message: "Updates cannot be empty" });
    }

    // Find and update the task
    const task = await Task.findOneAndUpdate(
      { _id: taskId, user: userId }, // Ensure the task belongs to the user
      updates,
      { new: true, runValidators: true } // Return the updated document and run validators
    );

    // If no task is found
    if (!task) {
      return res.status(404).json({ message: "Task not found or unauthorized" });
    }

    // Return the updated task
    res.status(200).json({ message: "Task updated successfully", task });
  } catch (error) {
    console.error("Error updating task:", error); // Debug log
    res.status(500).json({ message: "Error updating task", error: error.message });
  }
};


// Delete Task by User
exports.deletebyuser = async (req, res) => {
  try {
    const userId = req.user.id;
    const { id : taskId } = req.params;

    const task = await Task.findOneAndDelete({ _id: taskId, user: userId });

    if (!task) {
      return res.status(404).json({ message: "Task not found or unauthorized" });
    }

    res.status(200).json({ message: "Task deleted successfully" });
  } catch (error) {
    res.status(500).json({ message: "Error deleting task", error: error.message });
  }
};

// Admin: Get All Tasks
exports.alltask = async (req, res) => {
  try {
    if (req.user.role !== "admin") {
      return res.status(403).json({ message: "Access denied" });
    }

    const tasks = await Task.find().populate("user", "name email"); // Populate user details
    res.status(200).json({ tasks });
  } catch (error) {
    res.status(500).json({ message: "Error fetching all tasks", error: error.message });
  }
};

// Admin: Delete Any Task
exports.deletetaskbyadmin = async (req, res) => {
  try {
    if (req.user.role !== "admin") {
      return res.status(403).json({ message: "Access denied" });
    }

    const { id : taskId } = req.params;

    const task = await Task.findByIdAndDelete(taskId);

    if (!task) {
      return res.status(404).json({ message: "Task not found" });
    }

    res.status(200).json({ message: "Task deleted successfully" });
  } catch (error) {
    res.status(500).json({ message: "Error deleting task", error: error.message });
  }
};  



same as make chnage of both and solve the error const UserModel = require("../models/usermodel");
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");

exports.register = async (req, res) => {
  try {
    const { name, email, password } = req.body;

    // Validate input fields
    if (!name || !email || !password) {
      return res.status(400).json({ 
        message: "All fields are required.", 
        status: 0 
      });
    }

    // Check if the user already exists
    const existingUser = await UserModel.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ 
        message: "Email already registered.", 
        status: 0 
      });
    }

    // Hash the password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Create new user
    const newUser = new UserModel({
      name,
      email,
      password: hashedPassword,
    });

    // Save the user to the database
    await newUser.save();

    res.status(201).json({
      message: "User registered successfully.",
      newUser,
      status: 1,
    });
  } catch (error) {
    console.error("Error during user registration:", error);
    res.status(500).json({ 
      message: "Something went wrong.", 
      status: 0, 
      error: error.message 
    });
  }
};


exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;

    // Check if email and password are provided
    if (!email || !password) {
      return res.status(400).json({ message: "Email and password are required." });
    }

    // Find the user by email
    const user = await UserModel.findOne({ email });
    if (!user) {
      return res.status(404).json({ message: "User not found." });
    }

    // Verify the password
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return res.status(401).json({ message: "Invalid credentials." });
    }

    // Generate a JWT token
    const token = jwt.sign(
      { id: user._id, role: user.role }, // Include user details in the payload as needed
      process.env.JWT_SECRET, // Use your JWT secret from environment variables
      { expiresIn: '7d' } // Set token expiration time
    );

    // Set the token in an HTTP-only cookie
    res.cookie('token', token, {
      httpOnly: true, // Makes the cookie inaccessible to client-side scripts
      secure: process.env.NODE_ENV === 'production', // Set secure flag in production
      sameSite: 'strict', // Prevent CSRF attacks
      maxAge: 24 * 60 * 60 * 1000, // 1 day in milliseconds
    });

    // Send response
    res.status(200).json({ message: "Login successful", token });
  } catch (error) {
    res.status(500).json({ message: "Error logging in.", error: error.message });
  }
};


// User Logout
exports.logout = (req, res) => {
  try {
    res.clearCookie("token", {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
    });

    res.status(200).json({ message: "Logout successful." });
  } catch (error) {
    res.status(500).json({ message: "Error logging out.", error: error.message });
  }
};


// Get User Details
exports.getUserDetails = async (req, res) => {
  try {
    const user = await UserModel.findById(req.user.id);
    if (!user) {
      return res.status(404).json({ message: "User not found." });
    }

    res.status(200).json({ user });
  } catch (error) {
    res.status(500).json({ message: "Error fetching user details.", error: error.message });
  }
};

// Update Profile
exports.updateProfile = async (req, res) => {
  try {
    const { name, email } = req.body;

    const user = await UserModel.findById(req.user.id);
    if (!user) {
      return res.status(404).json({ message: "User not found." });
    }

    user.name = name || user.name;
    user.email = email || user.email;
    await user.save();

    res.status(200).json({ message: "Profile updated successfully.", user });
  } catch (error) {
    res.status(500).json({ message: "Error updating profile.", error: error.message });
  }
};

// Update Password
exports.updatePassword = async (req, res) => {
  try {
    const { oldPassword, newPassword } = req.body;

    const user = await UserModel.findById(req.user.id);
    if (!user) {
      return res.status(404).json({ message: "User not found." });
    }

    const isMatch = await bcrypt.compare(oldPassword, user.password);
    if (!isMatch) {
      return res.status(400).json({ message: "Old password is incorrect." });
    }

    user.password = await bcrypt.hash(newPassword, 10);
    await user.save();

    res.status(200).json({ message: "Password updated successfully." });
  } catch (error) {
    res.status(500).json({ message: "Error updating password.", error: error.message });
  }
};

// Get All Users (Admin Only)
exports.getAllUsers = async (req, res) => {
  try {
    const users = await UserModel.find();
    res.status(200).json({ users });
  } catch (error) {
    res.status(500).json({ message: "Error fetching users.", error: error.message });
  }
};

// Delete User (Admin Only)
exports.DeleteUser = async (req, res) => {
  try {
    const { id } = req.params;
    const user = await UserModel.findByIdAndDelete(id);

    if (!user) {
      return res.status(404).json({ message: "User not found." });
    }

    res.status(200).json({ message: "User deleted successfully." });
  } catch (error) {
    res.status(500).json({ message: "Error deleting user.", error: error.message });
  }
};




// Update Password
exports.updatePassword = async (req, res) => {
  try {
    const { oldPassword, newPassword } = req.body;

    const user = await UserModel.findById(req.user.id);
    if (!user) {
      return res.status(404).json({ message: "User not found." });
    }

    const isMatch = await bcrypt.compare(oldPassword, user.password);
    if (!isMatch) {
      return res.status(400).json({ message: "Old password is incorrect." });
    }

    user.password = await bcrypt.hash(newPassword, 10);
    await user.save();

    res.status(200).json({ message: "Password updated successfully." });
  } catch (error) {
    res.status(500).json({ message: "Error updating password.", error: error.message });
  }
};  using this backend write code for password change in  this api http://localhost:5000/api/v1/user/password/update and add frontend in this import { useState, useEffect } from "react";
import axios from "axios";
import { useNavigate } from "react-router-dom";
import { ToastContainer, toast } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";
import Cookies from "js-cookie";


const Profile = () => {
  const [user, setUser] = useState(null); // State to store user data
  const navigate = useNavigate();

  useEffect(() => {
    const fetchProfile = async () => {
      try {
        // Fetch user profile data from API
        const response = await axios.get("http://localhost:5000/api/v1/me", {
          withCredentials: true, // Include cookies in the request
        });

        if (response.status === 200) {
          setUser(response.data.user); // Update state with user data
        } else {
          toast.error("Failed to fetch user profile");
        }
      } catch (error) {
        console.error("Error fetching user profile:", error);
        toast.error("Authentication required. Redirecting to login...");
        setTimeout(() => {
          navigate("/login");
        }, 2000); // Redirect to login page
      }
    };

    fetchProfile();
  }, [navigate]);

  const handleLogout = () => {
    // Clear all data from localStorage
    localStorage.clear();
        Cookies.remove("token");
    
    // Send logout request to backend (change to POST if needed)
    axios.post("http://localhost:5000/api/v1/logout", {}, { withCredentials: true })
      .then(() => {
        toast.success("Logged out successfully");
        
        // Clear the user state after logout
        setUser(null); // Clear user data

        // Redirect to login page
        navigate("/login");
      })
      .catch((error) => {
        toast.error("Error logging out");
        console.error("Logout Error:", error);
      });
  };

  return (
    <div className="h-auto mt-3 p-4 md:p-8 bg-gray-50">
      <ToastContainer position="top-right" autoClose={3000} />
      <div className="text-[22px] md:text-[25px] font-bold">
        <h1>User Profile</h1>
      </div>
      {user ? (
        <div className="mt-6 flex items-center">
          {/* Profile Image or First Letter of Name */}
          <div className="w-16 h-16 rounded-full bg-blue-500 text-white flex items-center justify-center text-[18px] font-medium">
            {user.image ? (
              <img src={user.image} alt="User Avatar" className="w-full h-full object-cover rounded-full" />
            ) : (
              user.name.charAt(0).toUpperCase()
            )}
          </div>
          <div className="ml-4">
            <p className="text-[18px] font-medium">Hello, {user.name}!</p>
            <p className="text-[16px]">Email: {user.email}</p>
            <p className="text-[16px]">Role: {user.role}</p>
            {user.role === "admin" && (
              <button
                onClick={() => navigate("/admin")}
                className="mt-4 px-6 py-2 bg-blue-500 text-white rounded-md"
              >
                Go to Admin Panel
              </button>
            )}
            <button
              onClick={handleLogout}
              className="mt-4 ml-4 px-6 py-2 bg-red-500 text-white rounded-md"
            >
              Logout
            </button>
          </div>
        </div>
      ) : (
        <p className="mt-6 text-[16px]">Loading profile...</p>
      )}
    </div>
  );
};

export default Profile;  when user update password match old and update new add a button for update password and when update password open a popup for update write code for this and write complate code for all




exports.register = async (req, res) => {
  try {
    const { name, email, password } = req.body;

    // Validate input fields
    if (!name || !email || !password) {
      return res.status(400).json({ 
        success: false,
        message: "All fields are required." 
      });
    }

    // Check if a user with the same email exists
    const existingUser = await UserModel.findOne({ email });

    const verifyCode = Math.floor(100000 + Math.random() * 900000).toString();

    if (existingUser) {
      if (existingUser.isVerified) {
        return res.status(400).json({ 
          success: false,
          message: "Email already registered." 
        });
      } else {
        // Update existing unverified user with new password and verification code
        existingUser.password = await bcrypt.hash(password, 10);
        existingUser.verifyCode = verifyCode;
        existingUser.verifyCodeExpiry = new Date(Date.now() + 3600000); // 1 hour expiry
        await existingUser.save();

        // Send verification email
        const emailResponse = await sendVerificationEmail(email, name, verifyCode);
        if (!emailResponse.success) {
          return res.status(500).json({
            success: false,
            message: emailResponse.message,
          });
        }

        return res.status(200).json({
          success: true,
          message: "User already exists but email verification resent.",
        });
      }
    }
    // Hash the password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Create new user
    const newUser = new UserModel({
      name,
      email,
      password: hashedPassword,
      verifyCode,
      verifyCodeExpiry: new Date(Date.now() + 3600000), // 1 hour expiry
      isVerified: false,
    });

    await newUser.save();

    // Send verification email
    const emailResponse = await sendVerificationEmail(email, name, verifyCode);
    if (!emailResponse.success) {
      return res.status(500).json({
        success: false,
        message: emailResponse.message,
      });
    }

    res.status(201).json({
      success: true,
      message: "User registered successfully. Please verify your email.",
    });
  } catch (error) {
    console.error("Error during user registration:", error);
    res.status(500).json({
      success: false,
      message: "Something went wrong.",
      error: error.message,
    });
  }
}; this is register backend code chexk this frontend code and have any error to solve the error 

import { useState } from "react";
import { useNavigate } from "react-router-dom";
import axios from "axios";
import { ToastContainer, toast } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";
import { Link } from "react-router-dom";

const Register = () => {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [name, setName] = useState("");
  const navigate = useNavigate();

  const handleSubmit = async (e) => {
    e.preventDefault();

    if (password !== confirmPassword) {
      toast.error("Passwords do not match");
      return;
    }

    const data = {
      name,
      email,
      password,
      confirm_password: confirmPassword,
    };

    try {
      const response = await axios.post("http://localhost:5000/api/v1/register", data);

      console.log("Response:", response.data); // Logging success response

      if (response.data.status === 1) {
        toast.success(response.data.message);
        navigate(`/verify/${name}`); // Navigate to verify page
      } else {
        toast.error(response.data.message);
      }
    } catch (err) {
      console.error("Registration Error:", err.response?.data || err.message); // Logging error
      toast.error(err.response?.data?.message || "There was an error registering!");
    }
  };

  return (
    <div className="h-full flex items-center justify-center p-4 bg-gray-100">
      <ToastContainer position="top-right" autoClose={3000} />
      <div className="bg-white p-8 rounded-lg shadow-lg w-full max-w-md">
        <div className="text-3xl font-bold text-center text-gray-800 mb-6">Sign Up</div>
        <form onSubmit={handleSubmit}>
          <div className="mb-6">
            <label htmlFor="name" className="block text-sm font-medium text-gray-600">
              Full Name
            </label>
            <input
              type="text"
              id="name"
              name="name"
              placeholder="Enter Your Full Name"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="w-full p-3 border-b-2 border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-md mt-2"
              required
            />
          </div>
          <div className="mb-6">
            <label htmlFor="email" className="block text-sm font-medium text-gray-600">
              Email
            </label>
            <input
              type="email"
              id="email"
              name="email"
              placeholder="Enter Your Email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="w-full p-3 border-b-2 border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-md mt-2"
              required
            />
          </div>
          <div className="mb-6">
            <label htmlFor="password" className="block text-sm font-medium text-gray-600">
              Password
            </label>
            <input
              type="password"
              id="password"
              name="password"
              placeholder="Enter Password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="w-full p-3 border-b-2 border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-md mt-2"
              required
            />
          </div>
          <div className="mb-6">
            <label htmlFor="confirmPassword" className="block text-sm font-medium text-gray-600">
              Confirm Password
            </label>
            <input
              type="password"
              id="confirmPassword"
              name="confirmPassword"
              placeholder="Confirm Password"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              className="w-full p-3 border-b-2 border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-md mt-2"
              required
            />
          </div>
          <button
            type="submit"
            className="w-full py-3 bg-blue-600 text-white text-lg font-semibold rounded-lg hover:bg-blue-700 transition-all duration-300"
          >
            Sign Up
          </button>
        </form>
        <div className="mt-6 text-center text-sm text-gray-600">
          <span>Already have an account? </span>
          <Link to="/login" className="text-blue-600 hover:underline">
            Login
          </Link>
        </div>
      </div>
    </div>
  );
};

export default Register;  for user registration


exports.verifyCode = async (req, res) => {
  try {
      const { name } = req.params;  // Get name from URL params
      const { code } = req.body;  // Get OTP from request body

      const decodedUsername = decodeURIComponent(name);
      const user = await UserModel.findOne({ name: decodedUsername });

      if (!user) {
          return res.status(404).json({
              success: false,
              message: "User not found"
          });
      }

      const isCodeValid = user.verifyCode === code;
      const isCodeNotExpired = new Date(user.verifyCodeExpiry) > new Date();

      if (isCodeValid && isCodeNotExpired) {
          user.isVerified = true;
          await user.save();
          return res.status(200).json({
              success: true,
              message: "Account Verified Successfully"
          });
      } else if (!isCodeNotExpired) {
          return res.status(400).json({
              success: false,
              message: "Verification code has expired, please signup again to get a new code"
          });
      } else {
          return res.status(400).json({
              success: false,
              message: "Incorrect verification code"
          });
      }
  } catch (error) {
      console.error("Error verifying user", error);
      return res.status(500).json({
          success: false,
          message: "Error verifying user"
      });
  }
};  this is backend verify code and solve the error in frontend 

import { useState } from "react";
import { useParams, useNavigate } from "react-router-dom";
import axios from "axios";
import { ToastContainer, toast } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";

const Verify = () => {
  const { name } = useParams(); // Extracting name from URL
  const [otp, setOtp] = useState("");
  const navigate = useNavigate();

  const handleVerify = async (e) => {
    e.preventDefault();

    try {
      const response = await axios.post(`http://localhost:5000/api/v1/verify/${name}`, { otp });

      console.log("Response:", response.data); // Logging the response

      if (response.data.success) {
        toast.success(response.data.message);
        navigate("/login"); // Redirect to login after successful verification
      } else {
        toast.error(response.data.message);
      }
    } catch (err) {
      console.error("Error verifying user:", err.response?.data || err.message); // Logging the error
      toast.error(err.response?.data?.message || "Error verifying user");
    }
  };

  return (
    <div className="h-full flex items-center justify-center p-4 bg-gray-100">
      <ToastContainer position="top-right" autoClose={3000} />
      <div className="bg-white p-8 rounded-lg shadow-lg w-full max-w-md">
        <div className="text-3xl font-bold text-center text-gray-800 mb-6">Verify Account</div>
        <form onSubmit={handleVerify}>
          <div className="mb-6">
            <label htmlFor="otp" className="block text-sm font-medium text-gray-600">
              Enter OTP
            </label>
            <input
              type="text"
              id="otp"
              name="otp"
              placeholder="Enter OTP"
              value={otp}
              onChange={(e) => setOtp(e.target.value)}
              className="w-full p-3 border-b-2 border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-md mt-2"
              required
            />
          </div>
          <button
            type="submit"
            className="w-full py-3 bg-blue-600 text-white text-lg font-semibold rounded-lg hover:bg-blue-700 transition-all duration-300"
          >
            Verify
          </button>
        </form>
      </div>
    </div>
  );
};

export default Verify;  for verify user